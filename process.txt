2025
Итак, хочу базу дисков на quick.
Почему бы не добавить его в диск как приложение?
Потому что это будет уже не quick. Ибо авторизация. Хотя, можно так закочтылить:
 Получив симфони куку (допустим она есть, а нашей нет), делает запрос на метод Симфони. И если ок, то устанавливает свою.
 Дешево и сердито.
 
Но сначала делаю просто в хомяке.

Что должно быть
 Название (фильма, файла программы, файла архива программы)
 Точное имя файла
 Имя диска
 Описание конверта (бумажный, цвет; пластиковый, цвет, фабричный, пластиковая коробка)
    Это справочник в виде отдельной таблицы
 Описание коробки (обувная, стакан, другое)
	Это справочник в виде отдельной таблицы
 Артисты (часто придется искать фильмы по артистам, которые там снимались)
  (Текстовый перечень)
 Год выпуска (фильма, программы)
 Год записи
 Дополнительное поле 1
 Дополнительное поле 2
 
 DROP TABLE IF EXISTS hstor_file;
 CREATE TABLE hstor_file (
	id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
	user_id INTEGER,
	INDEX user_id (user_id),
	name VARCHAR(255) NOT NULL COMMENT 'Название (фильма, файла программы, файла архива программы)',
	INDEX name (name),
	file_name VARCHAR(255) NOT NULL COMMENT 'Точное имя файла',
	disk_name VARCHAR(255) DEFAULT NULL COMMENT 'Имя диска',
	convert_id INTEGER NOT NULL COMMENT 'Описание конверта',
	INDEX convert_id (convert_id),
	container_id INTEGER NOT NULL COMMENT 'Описание коробки',
	INDEX container_id (container_id),
	artists VARCHAR(4096) DEFAULT NULL COMMENT 'Артисты (Текстовый перечень)',
	content_year DATETIME DEFAULT NULL COMMENT 'Год выпуска (фильма, программы)',
	save_date DATETIME DEFAULT NULL COMMENT 'Год записи',
	additional_info VARCHAR(8192) DEFAULT NULL COMMENT 'Дополнительное поле 1',
	additional_info_2 VARCHAR(8192) DEFAULT NULL COMMENT 'Дополнительное поле 2',
	do_share TINYINT DEFAULT(0) COMMENT '1 если пользователь разрешил находить это в сети',
	is_deleted TINYINT(1) DEFAULT(0) COMMENT '1 если удален',
	delta INTEGER  COMMENT 'Порядковый номер'
 )engine=InnoDB, DEFAULT CHARSET  utf8 COLLATE=utf8_general_ci;
 
 DROP TABLE IF EXISTS hstor_convert;
 CREATE TABLE hstor_convert (
	id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
	name VARCHAR(255) NOT NULL COMMENT 'бумажный, цвет; пластиковый, цвет, фабричный, пластиковая коробка и т п',
	color VARCHAR(32) DEFAULT 'белый' COMMENT 'цвет',
	is_deleted TINYINT(1) DEFAULT(0) COMMENT '1 если удален',
	delta INTEGER  COMMENT 'Порядковый номер'
 )engine=InnoDB, DEFAULT CHARSET  utf8 COLLATE=utf8_general_ci;
 
 DROP TABLE IF EXISTS hstor_container;
 CREATE TABLE hstor_container (
	id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
	name VARCHAR(255) NOT NULL COMMENT 'обувная, стакан, другое',
	color VARCHAR(32) DEFAULT 'белый' COMMENT 'цвет',
	is_deleted TINYINT(1) DEFAULT(0) COMMENT '1 если удален',
	delta INTEGER  COMMENT 'Порядковый номер'
 )engine=InnoDB, DEFAULT CHARSET  utf8 COLLATE=utf8_general_ci;
 


Вобщем-то мне нужен простой CRUD с поиском.

Итак, что я вижу в случае логина,

Форму добавления, если понадобится, сдвинем потом вниз.
Конечно форму ввода имени файла (для поиска).
Возможно, сразу табличку с выводом имен. Кнопки редактирования и т п конечно.

Остановился на добавлении list.tpl.php в новый мастер.

2022
Итак, пора обнулиться.
Буду делать dto converter online.

Что хотим:
 1 Пользователь загружает JSON
 2 Сервер парсит его, и по очереди предлагает классы для корректировки.
   Например JSON это массив объектов, каждый из объектов содержит массив других объектов.
   Значит, надо предлагать в первую очередь такие объекты, которые не содержат массивов и объектов внутри.
   
   При парсинге массивов собирать поля из всех объектов, входящих в массив.
   
 3 Нейминг.
    Варианты:
    1 При первом проходе каждый класс именуется как Class_X_Dto
     где X просто инкрементится.
    2 Сразу пытаемся парсить имя массива и например если массив называется persons
      класс называется PersonDto
   
   Рекурсию не хочу, память на сервере не резиновая.
   
   Рассмотрим итерационный подход в случае массива в корне.
   Так как массив в корне не именованный, это будет Class_1_Dto
   Если в нем есть вложенные массивы, тип поля записываем как PersonDto[] (т. к. у вложенных массивов всегда есть имя)
   Если в нем есть вложенные объекты, тип поля записываем как PersonDto.
   
   В результате первой итерации имеем объект:
	{
		className: "Class_1_Dto",
		originalClassName: "Class_1_Dto", // после всех переименований пользователя это надо будет как-то собрать,
		type:"",  // совместимость с вложенными в fields
		name: "", // совместимость с вложенными в fields
		json: "", // совместимость с вложенными в fields. Здесь либо исходный json либо json всех полей всех элементов масссива (для нормальной выдаче все поля первого элемента)
		hasSubObjects: true, // так как надо определять, можно ли этот класс  передавать пользователю для редактирования
		hasUnsavedSubObject: true, // примет false когда все вложенные простые DTO сохранены
		originalParentClassName: "",
		fields: [
			{
				className: "", // для простых полей
				originalClassName: "",
				type: "string", // "undefined" если не удалось по значению понять
				name: "studentPassportNumber",
				json: "", // здесь для непростых вложенный json из исходного
				originalParentClassName: "Class_1_Dto",
				hasSubObjects: false,
				hasUnsavedSubObject: false,
		
			},
			{
				className: "PersonDto", // для вложенных объектов
				originalClassName: "PersonDto",
				type: "",
				name: "studentPerson",
				json: "", // здесь вложенный json из исходного
				originalParentClassName: "Class_1_Dto",
				hasSubObjects: true, // undefined ? 
				hasUnsavedSubObject: true, // undefined ? 
			},
			{
				className: "PersonDto[]", // для вложенных массивов
				originalClassName: "PersonDto[]",
				type: "",
				name: "studentPersons",
				json: "", // здесь вложенный json из исходного
				originalParentClassName: "Class_1_Dto", 
				hasSubObjects: true,   // undefined ? 
				hasUnsavedSubObject: true, // undefined ? 
			}
		]
	}
	
	Во все вложенные классы передаём именно originalClassName как ссылку на родителя.
	С их помощью мы сможем сообщить родителю, что объект отредактирован 
		и можно отдавать класс, содержащий вложенные dto на редактирование.
		
		
	В каждой следующей итерации отправляем json одного из сложных полей (originalClassName элемента из fields)
	 и originalClassName класса, в который эти поля вложены. Второй будет установлен как originalParentClassName.
	
	То есть у нас будет отдельно массив fields, в который добавляем в каждой итерации по объекту.
	И итератор по этому массиву.
	Для нашего примера будет после первой итерации четыре записи, а итератор мы устанавливаем на 1.
	
	Вторая итерация видит. что поле простое и просто увеличивает итератор на 1.
	Третья итерация парсит JSON объекта и добавляет записи в массив.
	Четвертая смотрит, видит что PersonDto уже обработан (а как понять?) и просто увеличивает итератор.
	
	В каждой итерации смотрим, если есть поля с вложенным JSON и originalParentClassName не пусто, 
		обновляем его поле hasSubObjects:true и hasUnsavedSubObject: true
	
Так, как размер массива увеличивается, но не бесконечно, мы дойдём до конца.
После того, как дошли до конца, сообщаем клиенту, что ок и отправляем последний 
	класс, не содержащий вложенных Dto на редактирование.
	
Здесь ещё есть вопрос, не сделать ли описанные итерации каждую по запросу с клиента, но кажется что это излишнее.

4 Редактирование пользователем.
 После того, как пользователь сохранил форму с данными одного класса, 
	в родительском классе надо увеличить счетчик обработанных саб-объектов.
  (надо его ввести в структуру выше). 
  Если после сохранения счетчик сохраненых саб-объектов равен счетчику саб-объектов (надо его тоже ввести в структуру выше)
   устанавливаем hasUnsavedSubObject: false;
   
  Такой класс может быть отправлен на редактирование.
  
После того, как все классы отредактированы запускаем этап генерации кода.
Здесь кажется просто переписываем с js на php и генерим. Всё, что получилось зипуем и даём пользователю скачать.
---------------------
4 Форма с исходным json.

 4.1 Натив или vue? -- натив. Потому что всё это просто за... надоело.
     - А почему на бэке тогда симфони а не php?
     - Давай так, если взлетит с текущими npm и node то vue
     - иначе - натив.
     - Эти вью компоненты - да они зачастую просто не удобны! Та самая простыня html, js и стили - и всё в одном файле!
     - А если выносить по максимуму во внешку? Типа в кажом методе просто вызов метода из внешнего класса?
        Или ещё лучше, @click="formController.onClick" 
        если конечно будет работать.
     
 4.2 На форме одна textarea для ввода JSON. После нажатия на сохранить
	- сначала получаем куку авторизации, затем сохраняем (если JSON парсится).
    - показываем поле ввода имени проекта. По умолчанию "Проект#N".
 
5 После нажатия на сохранить запускаем процесс итераций.
     То есть по одному запросу на каждую итерацию.
     Когда готово, тогда запрашиваем первый (очередной) класс
     и помещаем в форму редактирования класса.
 
6 Форма редактирования класса справа такая же, как в офлайн генераторе. 
		Слева список классов. 
			Содержащие только простые поля 
			и сложные поля, которые уже хотя бы раз сохранены
			кликабельны.
			Остальные не кликабельны и есть подсказка, почему.


100 При релизе не забыть проверить генерацию индексов в таблице
