Как всё-таки сделать по нормальному...

GetData - запрашиваем ресурс, если получилось сравниваем date_update с нашим и если на сервере новее обновляем.
                              если не получилось, тащим из склада, если нашли сохраняем себе  в locId
                              значение __local__ если оно есть, если его нет locId = 0
                              если нет и там -пишем что не получилось.
                              

SetData сначала отправляем на сервер , потом записываем в склад, если не получилось отправить, записываем в склад.
 При записи смотрим, нет ли такой в __local__ если есть, удаляем оттуда. Это на уровне базовой модели

Фоново:
Отправляем запрос с массивом данных, где каждый четный элемент id статьи, каждый нечетный - date_update статьи.
Сервер вернет массив тех id, которые имеют date_update более ранний, чем у нас.
Для каждого из них отправляем наши данные.
Берем все с id = 0  и тоже отправляем.

Как сделать новую запись?
Принцип тот же - отправляем, если получается - то прекрасно. 
Не получается - сохраняем модель с id 0.

Редактирование несохраненных на сервере.
Удалось отправить - вроде бы все понятно: получили id записали в основную копию, из "локал" удалили
Не удалось отправить: если id == 0, то смотрим locId  и find(locId) если он не пуст


//текучка:
Затестить еще раз модель.
Если сохраняем без id должна сохраняться в posts__local__N
Если сохраняем с id должна сохраняться в posts_N
Все они должны находится.


Если сохраняем без id должна сохраняться в posts__local__N
 а потом если тут же сохранили с id должна сохраняться в posts_N
  при этом posts__local__N исчезнуть.
  
Если сохраняем без id должна сохраняться в posts__local__N.
Обновили, получили по N
  id должен быть 0 а __local__ === N
  присваиваем id сохраняем должна сохраняться в posts_N
  при этом posts__local__N исчезнуть.
  

Сохранить с непустым тайтлом и непустым бади.
Сохранить другую запись с непустым тайтлом и пустым бади.
получить все.
Помотреть, что там у второй записи - скорее всего всё плохо, потому что find return this;
Выплясывается className обязательным для существования в потомках

лимит оффсет ни разу не проверен.
